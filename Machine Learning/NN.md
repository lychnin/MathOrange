# 神经网络Neural Networks
## basic key
对于神经网络的定义有很多，西瓜书采用了其中最为广泛的一种，即"神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所做出的的交互反应"

**我们在机器学习中所谈到的"神经网络"指的是"神经网络学习"，或者说是机器学习与神经网络两个学科领域的交叉部分。**

神经网络**最基本的成分是神经元模型(neuron)**

McCulloch and Pitts 于1943年抽象出"**M-P 神经元模型**"，神经元接收到来自n个其他神经元传递来的**输入信号**，这些输入信号通过**带权重的连接权**进行传递，之后将总输入**与阈值进行比较**，之后通过"**激活函数(activation function)**"处理以产生神经元的输出。

![](D:/VSCode/blog_picture/nn1.png)

**理想**中的激活函数当然是阶跃函数，但是由于其不光滑、不连续，实际常用的还是**Sigmoid函数**，又称"**挤压函数**"

将许多个这样的神经元按一定层次结构组合起来，就形成了神经网络模型，该模型是由许多个函数相互嵌套而成的。

## 感知机与多层网络
### 感知机

感知机(perceptron)由两层神经网络组成，输入层接收外界输入信号后传递给输出层，输出层是M-P神经元，亦称"阈值逻辑单元(threshold logic unit)"
![](D:/VSCode/blog_picture/nn2.png)
**感知机可以轻易地实现逻辑与或非运算，但无法实现非线性可分问题**

阈值与权重也可以通过学习得到，在实际处理过程中，为了方便，将阈值$\theta$视作一个权重为$\omega_{n+1}$的哑结点(其实就是将阈值当作权重处理)，==统一为权重的学习==

**感知机模型**：
$y=\begin{cases}
0 ~~~w^Tx_i- \theta <0
\\
1 ~~~ w^Tx_i- \theta \geq0
\end{cases}$

**策略**
==最小化分类误差==
$\sum_i(\hat{y}-y)(w^Tx_i-\theta)\\x_i \in M,M为误分类的样本集合\\\hat{y}是输出值,y是真实值，但如果只是单纯的计算(\hat{y}-y)的话其正负会波动，此外即便我们使用||(\hat{y}-y)||,我们也只是知道有多少个样本分错了但不知道错误程度，所以再引入(w^Tx_i-\theta)可以度量错误程度(也就是分错的样本距离正确的划分超平面的距离)$

所以我们的目标就进而变为$\displaystyle \mathop{min}\limits_{w,\theta}\sum_{x_i \in M} (\hat{y_i}-y_i)(w^Tx_i-\theta)$

经过**梯度下降法**计算得到权重的更新式：
$w+\Delta w\to w\\ \Delta w=\eta (y_i-\hat{y})x_i$

$\eta$称为学习率,是一个小正数

感知机只有输出层进行激活函数处理，即只拥有一层功能神经元(functional neuron)，学习能力有限，上述与、或、非问题都为线性可分问题(一个线性超平面可以分开)，感知机的学习过程一定会收敛(converge)(==收敛到线性超平面==)以求得适当的权向量，否则感知机学习过程会发生震荡，w难以稳定不能求得合适解(==比如说对于非线性可分的问题就无法求解==)

![](D:/VSCode/blog_picture/nn4.png)
### 多层网络
要求解非线性可分问题，需要考虑使用多层功能神经元，输入层与输出层之间的神经元就称为隐层或者隐含层(hidden layer),==隐含层与输出层都是有激活函数的功能神经元==
![](D:/VSCode/blog_picture/nn3.png)

更一般地，常见的神经网络是"**多层前馈神经网络(multi-layer feedforward neural networks)**":每层神经元与下一层之间全互联，神经元之间不存在同层连接，也不存在跨层连接。
神经网络的学习过程，就是**根据训练数据来调整神经元之间的"连接权(connection weight)"以及每个功能神经元的阈值**，权与阈值也就是学到的东西

### 误差逆传播算法(反向传播算法)
多层网络的学习能力比只有单层的感知机要强得多，要训练多层网络，也需要更强大的学习算法，==误差逆传播算法BP/error BackPropagation==是其中最为杰出的代表，它是迄今最成功的神经网络学习算法。

BP算法也并不是只可用于多层前馈神经网络，还可用于其他类型的神经网络。但通常说"BP网络"时，指的是用BP算法训练的多层前馈神经网络。

输入:
训练集$D=\{(x_1,y_1),(x_2,y_2),\dotsb,(x_m,y_m)\},x_i \in R^d,y_i \in R^l\\x为d维向量,y为l维向量$

**模型**:
![](D:/VSCode/blog_picture/nn5.png)

模型参数：
$d:d个输入神经元，接收样本的d个属性作为输入,\\
q:q个隐层神经元，接收输入层神经元的输入,\\
l:l个输出层神经元，接收q个隐层神经元的输出作为输入，产生输出,\\
v_{ih}:第i个输入层神经元与第h隐层神经元相连的权值,\\
w_{hj}:第h个隐层神经元与第j个输出层神经元相连的权值,\\
a_h:第h个隐层神经元接收的输入,\\
b_h:第h个隐层神经元产生的输出,\\
\beta_j:第j个输出层神经元接收的输入,\\
y_j:第j个输出层神经元产生的输出$

**策略**:
**最小化均方误差**
$E_k=\displaystyle \frac{1}{2}\sum_{j=1}^l(\hat{y_j^k}-y_j^k)^2\\
NOTES:\hat{y_j^k}为第j个输出层的输出，也就是对一个样本第j维所属类别的预测
\\y_j^k:一个样本第j维所属类别的标记$

BP是一个迭代的学习算法，在迭代的每一轮中采用广义的感知机学习规则对参数进行更新估计。
任一参数的更新式为:
$v+\Delta v\to v\\
v为泛指$
**推导过程见西瓜书p103**
==推导过程中注意导数的正负号==
学习率$\eta \in (0,1)控制着算法每一轮迭代中的更新步长，若太大则容易振荡，太小则收敛速度过慢，常取为0.1，有时为了精细调节，在隐层到输出层中涉及到的$\eta$与在输入层到隐层中涉及到的$\eta$设置为两个值。

算法流程：
![](D:/VSCode/blog_picture/NN6.png)
==此算法为标准BP算法==，==每次仅针对一个样例==进行参数更新，算法的==更新规则是基于单个的$E_k$推导而得==，参数==更新频繁==，而且针对不同样例更新的效果可能出现抵消现象，为了达到同样的累积误差极小点，需要进行更多次数的迭代。

**最小化累积误差**
如果推导基于累积误差最小化$\frac{1}{m}\sum_{k=1}^m E_k$的更新规则，就得到了==累积误差逆传播算法(accumulated error backpropagation)==，它==读取整个训练集后才对参数进行一次更新==，其参数更新频率低得多。

但是在很多任务中，累积误差下降到一定程度后，进一步下降会非常缓慢，这是标准BP往往会更快得到较好的解,在数据量大时非常明显。

读取训练集一遍称为一轮(one round/one epoch)

### 隐层神经元个数的确定
一个包含足够多神经元隐层的多层前馈神经网络可以任意精度逼近任意复杂度的连续函数，但是如何设置隐层神经元的个数仍然是个未决问题，实践中常靠==试错法==

### 缓解过拟合
#### 早停early stopping
将数据分为训练集与验证集，训练集用于计算梯度，更新权值与阈值，验证集估计误差，当训练集误差降低但验证集误差升高时停止训练，返回具有最小验证集误差的权值与阈值

#### 正则化regularization
在误差目标函数中增加一个用于描述网络复杂度的部分，令误差目标函数变为:
$E=\lambda \frac{1}{m}\sum _{k=1}^m E_k+(1-\lambda )\sum_i w_i^2\\
\lambda \in (0,1)用于对经验误差与网络复杂度进行折中，常通过交叉验证法来估计$

## 全局最小与全局极小
 若用E表示神经网络在训练集上的误差，那么它是一个关于连接权与阈值的参数，此时==神经网络的训练过程可以看作参数寻优过程，即在参数空间中，寻找一组最优参数使得E最小==。
 ![](D:/VSCode/blog_picture/nn7.png)
### 局部极小local minimum
若存在$\epsilon > 0使得\forall (w;\theta) \in \{ (w;\theta) | ||(w;\theta)-(w^*-\theta^*)||\leq \epsilon\}$都有$E(w; \theta)\geq E(w^*;\theta^*)$,则$(w^*; \theta^*)$为局部极小==解==

此时的$E(w^*; \theta^*)$为局部极小==值==
### 全局最小global minimum
若对参数空间中的任意$(w;\theta)都有E(w;\theta)\geq E(w^*;\theta^*),则(w^*;\theta^*)$为全局最小==解==

此时的$E(w^*; \theta^*)$为全局最小==值==

在参数空间中，显然，梯度为0时的点，只要误差函数值小于邻点的误差函数值就是局部极小点(解)，==可能存在多个局部极小点，但一定只有一个全局最小点==我们当然希望找到的是全局最小点

### 跳出局部极小的策略
基于梯度搜索是最为广泛使用的参数寻优方法，我们通过计算误差函数在当前点的梯度，然后根据梯度确定搜索方向，直到梯度为0，意味着迭代停止，找到了解。

如果误差函数仅有一个局部极小，那么此时找到的解也是全局最小，但是若有多个局部极小，那么不能保证找到的解就是全局最小。对于后一种情形，我们称参数寻优陷入了局部极小。

#### 跳出局部极小的策略：
- 以多组不同参数值初始化多个神经网络，训练后，取其中误差最小的解作为最终参数。相当于陷入不同局部极小后，选择最可能是全局最小的那一个。
- 模拟退火simulated annealing，每一步都以一定的概率接受比当前解更差的结果，迭代过程中，接受“次优解”的概率要随着时间的推移而逐渐降低，从而保证算法稳定。
- 随机梯度下降，计算梯度时加入随机因素，即时陷入局部极小，梯度也不为0，就有机会跳出真正的局部极小。
- 遗传算法也常用来训练神经网络来更逼近全局最小。

==但这些方法大多是启发式，缺乏理论保障。==

## 其他常见的神经网络
#### RBF网络Radial Basis Function(径向基函数网络)
径向基函数/Radial Basis Function/RBF:沿径向对称的标量函数,(比如说圆),从代数角度看,是取值仅依赖于该点与原点(可以是指定的任一点)的距离(因为只与距离有关，所以同距离的不同方向的点效果相同，所以沿径向(直径的方向)对称)

该网络使用径向基函数作为隐层的神经元激活函数，输出层为对隐层神经元输出的线性组合。RBF网络表示为$\phi(x)=\displaystyle \sum_{i=1}^qw_i\rho(x;,c_i)$
$c_i$表示第i个隐层神经元所对应的中心，$w_i$表示第i个隐层神经元所对应的权重
$\rho(x,c_i)$为径向基函数

常用径向基函数为高斯径向基函数：
$\rho(x,c_i)=e^{\beta_i||x-c_i||^2}$

具有足够多的隐层神经元的RBF网络可以以任意精度逼近任意连续函数

两步训练RBF网络:
- 确定神经元中心$c_i$
- 利用BP算法确定参数$w_i$和$\beta_i$
#### ART(Adaptive Resonance Theory,自适应谐振理论)网络
竞争型学习的重要代表
由比较层、识别层、识别阈值、重置模块组成
其中，比较层接收输入样本，识别层每个神经元对应一个模式类，神经元数目可在训练过程中动态增加以增加新的模式类

**模型**：
- 接收比较层输入样本
- 识别层神经元在竞争中产生获胜的神经元，竞争方式为==计算输入向量与每个识别层神经元所对应的模式类的代表向量之间的距离，距离最小者胜。==
- 获胜神经元激活，其他神经元抑制
- 若输入向量与获胜神经元所对应的向量之间的相似度大于识别阈值，那么输入向量就属于该代表向量所属类别，同时更新连接权，使得以后在接收到相似输入样本时该模式类会计算出更大的相似度，使得该神经元更有可能获胜
**否则，重置模块将在识别层增设一个新的神经元，其代表向量设置为当前输入向量**

==识别阈值越高，产生的模式类更精细，反之，更粗略==

ART很好地缓解了“可塑性-稳定性窘境”，可塑性指的是神经网络要有学习新知识的能力，稳定性指的是神经网络在学习新知识时要保持对就知识的记忆

他可以进行增量学习或在线学习
#### SOM网络(Self-Organizing Map,自组织映射)
一种竞争型学习型的无监督神经网络
他可以将高维输入数据映射到低维空间(通常为二维)，同时保持输入数据在高维空间的拓扑结构，即将高维空间中相似的样本点映射到网络输出层中的邻近神经元。
![](D:/VSCode/blog_picture/nn8.png)
如图，SOM网络中的输出层神经元以矩阵方式排列在二维空间中，每个神经元都拥有一个权向量，网络在接收输入向量后，将会确定==输出层获胜神经元==，它==决定了该输入向量在低维空间中的位置==
==SOM的训练目标为为每个输入层神经元找到合适的权向量，以达到保持拓扑结构的目的==

训练过程:
- 接收样本
- 输出层神经元计算该样本与自身携带的权向量之间的距离，距离最近的神经元成为竞争获胜者，称为最佳匹配单元
- 最佳匹配单元及其邻近神经元的权向量将被调整使得这些权向量与当前输入样本的距离缩小
- 这个过程不断迭代，直至收敛
### 自适应网络
==一般的神经网络模型假定网络结构是实现固定的，训练的目的是利用训练样本来确定合适的连接权与阈值==

然而==结构自适应网络则将网络结构也作为学习的目标之一，并希望能在训练过程中找到最符合数据特点的网络结构==

#### 级联相关网络
级联相关网络(Cascade-Correlation)是自适应网络的重要代表

两个成分："**级联**"、"**相关**"
级联指的是建立层次连接的层级结构：
刚开始训练时，只有输入层与输出层，随着==训练进行新的隐层神经元加入==，从而逐渐创建起层级结构，当==新的隐层神经元加入==时，其==输入端连接权值是冻结固定的(如图,输入端连接权为黑色，输出端为红色，黑色固定，红色可变)==

![](D:/VSCode/blog_picture/nn9.png)

相关是指通过最大化新神经元的输出与网络误差之间的相关性(correlation)来训练相关的参数

==与前馈神经网络相比，它无需设置网络层数、隐层神经元数目，且训练速度较快，但是数据较小时容易过拟合==

### 递归神经网络
递归神经网络(recurrent neural network)允许出现环形结构，从而可让一些神经元的输出反馈回来作为输入信号，使得网络在t时刻的输出与t时刻的输入与t-1时刻的输出都有关，==可以处理与时间有关的动态变化==
#### Elman网络
递归神经网络之一
隐层神经元采用Sigmoid激活函数，网络训练使用推广的BP算法
![](D:/VSCode/blog_picture/nn10.png)
#### Boltzmann机
有一类模型为网络状态定义一个“能量”，能量最小化为理想状态。

Boltzmann机就是基于能量的模型，结构为:
![](D:/VSCode/blog_picture/nn11.png)

神经元分为：
显层：数据的输入与输出
隐层：数据的内在表达
所有神经元均为布尔型，1表示激活，0表示抑制

状态向量的Boltzmann机能量定义为:
$E(s)=\displaystyle -\sum_{i=1}^{n-1}\sum_{j=i+1}^n w_{ij}s_is_j-\sum^n_{i=1}\theta_js_i$
网络中神经元以任意不依赖于输入值的顺序进行更新，则网络最终可以达到Boltzmann分布：此时状态向量s的概率仅由能量与所有可能的状态向量(每个训练样本都看作一个状态向量)的能量确定:
$P(s)=\frac{e^-E(s)}{\sum_te^{-E(t)}}$ 

==标准的Boltzmann机为全连接图，但其复杂度高很难解决问题，现实中采用受限的Boltzmann机(RBM,Restricted Boltzmann Machine)==

受限的Boltzmann机常采用"对比散度/CD,Contrastive Divergence"算法进行训练
v与h表示显层与隐层的状态向量
$P(v|h)=\prod _{i=1}^dP(v_i|h)~~~(1)\\P(h|v)=\prod _{j=1}^qP(h_j|v)~~(2)
$
**训练过程**：
- 对训练样本v，先根据(2)计算隐层神经元状态的概率分布
- 根据这个概率分布采样得到h
- 根据(1)产生v'
- 根据(2)产生h'
- 连接权的更新公式:
$\Delta w=\eta(vh^T-v'h'^T)$